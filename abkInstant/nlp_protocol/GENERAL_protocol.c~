#include <iostream>
#include <list>
#include <string.h>
#include <string>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <ifaddrs.h>
#include <time.h> 
#include "protocol.h"
#include "devices.h"
#include "package_commands.h"
#include <termios.h>
#include <unistd.h>
#include <pthread.h>
//#include <functional>

//#include "udp_transponder.h"
#include "serverthread.h"
#include "GENERAL_protocol.h"
#include "AUDIO_protocol.h"
#include "CAMERA_protocol.h"
#include "FILE_protocol.h"
#include "HMI_protocol.h"
#include "CAN_protocol.h"
#include "thread_control.h"
#include "nlp_extraction.hpp"
#include "prefilter.hpp"
#include "client_to_socket.hpp"
#include "client_memory.hpp"




/* Following are sentences generated by this object:
 * 
 * "which adrenaline boards do you have?"
 * "how many "+mBoardType+" boards do you have?"
 * "call board instance "+mInstance+" by "+mName+"."
 * "select board instance "+mInstance+"." 
 * "set camera tilt to "+mDegrees+"."  
 * "set camera pan to "+mDegrees+"." 
 * "set camera tilt to "+mTiltDegrees+" and pan to "+mPanDegrees+"." 
 * "set lowside driver pin "+mPin+" to "+mValue+"."
 * "read analog pin "+mPin+"." 
 * "read all analog pins."
 * "set GPIO pin "+mPin+" to "+mVal+"." 
 * "set GPIO pin "+mPin+" as "+direction+"." 
 * "read GPIO pin "+mPin+"." 
 * "send all CAN traffic to me on port "+mPort+"."
 * "listen to my CAN traffic." 
 * "listen to CAN message: "+mMessage+"."
 *   
 * "what adrenaline boards do you have?"
 * "set camera tilt to "+mDegrees+"."
 * "set camera tilt to "+mDegrees+"."
 * "set camera pan to "+mDegrees+"." 
 * "set camera tilt to "+mTiltDegrees+" and pan to "+mPanDegrees+"." 
 * "set lowside driver pin "+mPin+" to "+mValue+"." 
 * "read analog pin "+mPin+"."
 * "read all analog pins." 
 * "set GPIO pin "+mPin+" to "+mValue+"."
 * "set GPIO pin "+mPin+" as "+direction+"."
 * "read GPIO pin "+mPin+"." 
 * "send all CAN traffic to me on port "+mPort+"."  
 * "listen to my CAN traffic." 
 * "listen to CAN message: "+mMessage+"." 
 */
 
 /* This General parsing should look for phrases like:
 	No, that's not what i meant.
 	You misunderstood me.
 	It's a new phrase.
 	Next time I say "..." do such and such [established phrase]
 */

// Response language:
BOOL 			nlp_reply_formulated = FALSE;
char			NLP_Response[255];

/*****************************************************************
Do the work of the Telegram :
return  TRUE = GPIO Telegram was Handled by this routine
		FALSE= GPIO Telegram not Handled by this routine
*****************************************************************/
//using namespace std;
static std::list<struct sObject*>  subject_list;
static std::list<std::string> 		verb_list;
static std::list<std::string> 		preposition_list;
static std::list<struct sObject*>  object_list;

static void init_verb_list()
{
	verb_list.push_back( "login" );
	verb_list.push_back( "close" );
	verb_list.push_back( "power" );
	verb_list.push_back( "route" );
	verb_list.push_back( "incoming" );
	verb_list.push_back( "end" );
	verb_list.push_back( "send" );
	verb_list.push_back( "synthesize" );
	verb_list.push_back( "press" );
	verb_list.push_back( "mouse" );
	verb_list.push_back( "are" );	
	verb_list.push_back( "have" );
	verb_list.push_back( "get" );	
	verb_list.push_back( "set" );	
	verb_list.push_back( "I am" );		
}

static void init_subject_list()
{
	// Also need aliases (ie synonyms):
	struct sObject* ptr = new struct sObject("camera", 2 );
	subject_list.push_back( ptr );
	subject_list.push_back( new sObject("camera tilt",  2 ) 	);
	subject_list.push_back( new sObject("camera pan", 2 ) 	);
	subject_list.push_back( new sObject("tilt angle", 2 ) 	);
	subject_list.push_back( new sObject("pan angle", 2 ) 	);

	subject_list.push_back( new sObject("audio", 	 3 ) 	);		
	subject_list.push_back( new sObject("microphone", 3 ) 	);

	subject_list.push_back( new sObject("tv", 	  4)		 );		
	subject_list.push_back( new sObject("display", 4)		 );	
	subject_list.push_back( new sObject("hdmi",	  4)		 );
	
	subject_list.push_back( new sObject("adrenaline boards",	  5) );
	subject_list.push_back( new sObject("lowside driver",	  6) );
	subject_list.push_back( new sObject("analog pin",	  	  7) );
	subject_list.push_back( new sObject("GPIO pin",	  8)		 );
	
	subject_list.push_back( new sObject("big motor",	  	  9) );
	subject_list.push_back( new sObject("tilt sensor",	 10) );
	subject_list.push_back( new sObject("board instance",	 11) );
	subject_list.push_back( new sObject("instance",	 12) );
	
	subject_list.push_back( new sObject("CAN traffic",	 12) );
	subject_list.push_back( new sObject("CAN message",	 12) );					
}
static void init_preposition_list()
{ // Object might be a numerical value preceded by a preposition.
	// ie. "set camera tilt _to_ _25.5 degrees"
	// prepositions to look for :
	//		to by as 
	preposition_list.push_back( "to" );
	preposition_list.push_back( "as" );	
	preposition_list.push_back( "by" );		
	preposition_list.push_back( "for");
	preposition_list.push_back( "in" );
}

static void init_object_list()
{ // Object might be a numerical value preceded by a preposition.
	// ie. "set camera tilt _to_ _25.5 degrees"
	// prepositions to look for :
	//		to by as 
	
	// Also need aliases (ie synonyms):
	struct sObject* ptr = new struct sObject("you", 2 );
	subject_list.push_back( ptr );	
	subject_list.push_back( new sObject("me",  2 ) 	);
	subject_list.push_back( new sObject("me",  2 ) 	);	
}
static void init_word_lists()
{
	init_verb_list();
	init_subject_list();
	init_object_list();
	init_preposition_list();
}

void Init_General_Protocol( )
{
	init_word_lists();
}

int find_subject( char* mSubject )
{
	std::list<sObject*>::iterator iter = subject_list.begin();
	int i=0;
	for ( ; iter != subject_list.end(); iter++, i++)
	{
		if ( (*iter)->name.compare(mSubject) == 0 )
		{
			
		}
	}
}

/*******************************************
 *  Find the direct object of the sentence
 *  Return :	index into the subject_list 
 ********************************************/
struct sObject* extract_subject( char* mSentence )
{
	std::string  Sentence(mSentence);
	std::list<sObject*>::iterator iter = subject_list.begin();
	int i=0;
	for ( ; iter != subject_list.end(); iter++, i++)
	{
		if (Sentence.find( (*iter)->name ) != std::string::npos)
		{
			printf("Subject=%s\n", (*iter)->name.c_str() );
			
			return (*iter);
		}
	}
	return (NULL);
}
std::string*    extract_verb		( char*  mCommand )
{
	return extract_word( mCommand, &verb_list );
}

int get_preposition_index(char*  mSentence)
{
	std::string  Sentence(mSentence);
	std::list<std::string>::iterator iter = preposition_list.begin();
	int i=0;
	for ( ; iter != preposition_list.end(); iter++, i++)
	{
		int result = Sentence.find( (*iter).c_str() );
		if (result != std::string::npos)
		{
			printf("Prep at Sent[%d]\n", result );
			return result;
		}
	}
	return (-1);
}

/*****************************************************************
the direct object - ie end of sentence portion.  
This is a copy of verb.  So need to rethink this!
*****************************************************************/
struct sObject* extract_object(char*  mSentence)
{
	std::string  Sentence(mSentence);
	std::list<sObject*>::iterator iter = object_list.begin();
	int i=0;
	for ( ; iter != object_list.end(); iter++, i++)
	{
		if (Sentence.find( (*iter)->name.c_str() ) != std::string::npos)
		{ 
			//printf("Object=%s\n", (*iter)->name.c_str() );
			return (*iter);
		}
	}
	return (NULL);
}


extern int connfd;

/*****************************************************************
Do the work of the Telegram :
PARAMS : 
	mSentence 		- pointer to a buffer which begins with text (data may follow end of string).
	mbegin_index	- index within the mSentence buffer (up to 5MB)

return  TRUE = GPIO Telegram was Handled by this routine
		FALSE= GPIO Telegram not Handled by this routine
*****************************************************************/
char* Parse_Statement(char*  mSentence)
{	
	if (mSentence==NULL) return mSentence; 
	printf( "Sentence:|%s|\n", mSentence );

	bool okay = prefilter_text(mSentence);
 	char* end_of_telegram = mSentence + strlen(mSentence) +1/*nullterminator*/;
	//char* new_end_of_telegram = end_of_telegram;
	int result =-1;
	
	if (!okay)
	{
		//printf("Prefilter determined a VoiceResponse!\n");
		if (ClientRequestPending)
		{
			// For those cases where the response comes from the other end:
			cli_ipc_write_response( mSentence );	
			ClientRequestPending = false;
		}
		return end_of_telegram;	
	}

	if (strcmp(mSentence, "I don't understand. Ignoring.")==0)
		return;
	
	// AUDIO:
	result = Parse_Audio_Statement( mSentence );
	if (result>=0) 
		return (end_of_telegram + result);	

	result = Parse_Camera_Statement( mSentence );
	if (result>=0)	
		return (end_of_telegram + result);		

	result = Parse_CAN_Statement( mSentence );
	if (result>=0)	
		return (end_of_telegram + result);		
	
	result = Parse_File_Statement  ( mSentence );	/* ie. File transfer, directory, backup, etc. */		
	if (result>=0)	
		return (end_of_telegram + result);		
		
	result = Parse_HMI_Statement   ( mSentence ); 	/* ie mouse, keyboard, PS3 controller, etc. */	
	if (result>=0)	
		return (end_of_telegram + result);
/*
	result = Parse_IMAGE_Statement   ( mSentence ); 	
	if (result>=0)	
		return (end_of_telegram + result);
	result = Parse_GPIO_Statement   ( mSentence ); 	
	if (result>=0)	
		return (end_of_telegram + result);

*/

	// Not handled:
	nlp_reply_formulated = TRUE;
	strcpy (NLP_Response, "I don't understand. Ignoring.");		
	return end_of_telegram;
}




