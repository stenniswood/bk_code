#include <iostream>
#include <list>
#include <string.h>
#include <string>
#include <vector>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <ifaddrs.h>
#include <time.h> 
#include "protocol.h"
#include "devices.h"
#include "package_commands.h"
#include <termios.h>
#include <unistd.h>
#include <pthread.h>

#include "nlp_extraction.hpp"
#include "prefilter.hpp"
#include "client_to_socket.hpp"
#include "client_memory.hpp"
#include "nlp_sentence.hpp"

#include "serverthread.hpp"
#include "GENERAL_protocol.hpp"
#include "AUDIO_protocol.hpp"
#include "CAMERA_protocol.hpp"
#include "FILE_protocol.hpp"
#include "HMI_protocol.hpp"
#include "CAN_protocol.hpp"
#include "math_protocol.hpp"
#include "robot_arms_protocol.hpp"
#include "robot_legs_protocol.hpp"
#include "SEQUENCER_protocol.hpp"
#include "calendar_protocol.hpp"
#include "self_identity.hpp"
#include "ThreeD_object_protocol.hpp"
#include "easter_eggs_protocol.hpp"




 

/* Following are sentences generated by this object:
 * 
 * "which adrenaline boards do you have?"
 * "how many "+mBoardType+" boards do you have?"
 * "call board instance "+mInstance+" by "+mName+"."
 * "select board instance "+mInstance+"." 
 * "set camera tilt to "+mDegrees+"."  
 * "set camera pan to "+mDegrees+"." 
 * "set camera tilt to "+mTiltDegrees+" and pan to "+mPanDegrees+"." 
 * "set lowside driver pin "+mPin+" to "+mValue+"."
 * "read analog pin "+mPin+"." 
 * "read all analog pins."
 * "set GPIO pin "+mPin+" to "+mVal+"." 
 * "set GPIO pin "+mPin+" as "+direction+"." 
 * "read GPIO pin "+mPin+"." 
 * "send all CAN traffic to me on port "+mPort+"."
 * "listen to my CAN traffic." 
 * "listen to CAN message: "+mMessage+"."
 *   
 * "what adrenaline boards do you have?"
 * "set camera tilt to "+mDegrees+"."
 * "set camera tilt to "+mDegrees+"."
 * "set camera pan to "+mDegrees+"." 
 * "set camera tilt to "+mTiltDegrees+" and pan to "+mPanDegrees+"." 
 * "set lowside driver pin "+mPin+" to "+mValue+"." 
 * "read analog pin "+mPin+"."
 * "read all analog pins." 
 * "set GPIO pin "+mPin+" to "+mValue+"."
 * "set GPIO pin "+mPin+" as "+direction+"."
 * "read GPIO pin "+mPin+"." 
 * "send all CAN traffic to me on port "+mPort+"."  
 * "listen to my CAN traffic." 
 * "listen to CAN message: "+mMessage+"." 
 */
 
 /* This General parsing should look for phrases like:
 	No, that's not what i meant.
 	You misunderstood me.
 	It's a new phrase.
 	Next time I say "..." do such and such [established phrase]
 */

// Response language:
BOOL 			nlp_reply_formulated = FALSE;
char			NLP_Response[255];

/*****************************************************************
Do the work of the Telegram :
return  TRUE = GPIO Telegram was Handled by this routine
		FALSE= GPIO Telegram not Handled by this routine
*****************************************************************/
//using namespace std;
//static std::list<struct vsObject*>  subject_list;
static std::list<std::string> 		verb_list;
//static std::list<struct vsObject*>  object_list;


void Init_General_Protocol( )
{
    Init_Audio_Protocol();
    Init_Camera_Protocol();
    Init_CAN_Protocol();
    Init_FILE_Protocol();
    Init_HMI_Protocol();
    Init_Math_Protocol();
    
    Init_Robot_Legs_Protocol();
    Init_Self_Identity_Protocol();
    Init_Robot_Legs_Protocol();
    Init_Sequencer_Protocol();
    
    init_preposition_list();
}


extern int connfd;
void form_response(const char* mTextToSend)
{
    strcpy( NLP_Response, mTextToSend);
    CLIENT_Response =  NLP_Response;
    ClientRequestPending = true;
    nlp_reply_formulated = TRUE;
}


/*****************************************************************
Do the work of the Telegram :
PARAMS : 
	mSentence 		- pointer to a buffer which begins with text (data may follow end of string).
	mbegin_index	- index within the mSentence buffer (up to 5MB)

return  TRUE = GPIO Telegram was Handled by this routine
		FALSE= GPIO Telegram not Handled by this routine
*****************************************************************/
char* Parse_Statement(char*  mSentence)
{	
	if (mSentence==NULL) return mSentence; 
	printf( "Sentence:|%s|\n", mSentence );

    Sentence theSentence( mSentence );
    
    bool vr = theSentence.is_voice_response();
 	char* end_of_telegram = mSentence + strlen(mSentence) +1/*nullterminator*/;
	int result =-1;	
	if (vr)
	{
		//printf("Prefilter determined a VoiceResponse!\n");
		if (ClientRequestPending)
		{
			// For those cases where the response comes from the other end:
			cli_ipc_write_response( mSentence, "instant" );	
			ClientRequestPending = false;
		}
		nlp_reply_formulated = false;
		return end_of_telegram;
	}

	if (strcmp(mSentence, "I don't understand. Ignoring.")==0)
		return end_of_telegram;
    
    result = Parse_Calendar_Statement( theSentence );
    if (result>=0)          return (end_of_telegram + result);

    result = Parse_Math_Statement( theSentence );
	if (result>=0)          return (end_of_telegram + result);

    result = Parse_Self_Identity_Statement( theSentence );
    if (result>=0)          return (end_of_telegram + result);

    result = Parse_Robot_Legs_Statement( theSentence );
    if (result>=0)          return (end_of_telegram + result);

    result = Parse_Robot_Arms_Statement( theSentence );
    if (result>=0)          return (end_of_telegram + result);

    result = Parse_EasterEggs_Statement( theSentence );
    if (result>=0)          return (end_of_telegram + result);

    result = Parse_ThreeD_Statement( theSentence );
    if (result>=0)          return (end_of_telegram + result);
    
    result = Parse_Sequencer_Statement( theSentence );
    if (result>=0)          return (end_of_telegram + result);
    
    
	// AUDIO:
	result = Parse_Audio_Statement( mSentence );
	if (result>=0)          return (end_of_telegram + result);

	result = Parse_Camera_Statement( mSentence );
	if (result>=0)			return (end_of_telegram + result);

	result = Parse_CAN_Statement( theSentence ); 
	if (result>=0)			return (end_of_telegram + result);
	
	result = Parse_File_Statement  ( mSentence );	/* ie. File transfer, directory, backup, etc. */		
	if (result>=0)			return (end_of_telegram + result);
		
	result = Parse_HMI_Statement   ( mSentence ); 	/* ie mouse, keyboard, PS3 controller, etc. */	
	if (result>=0)          return (end_of_telegram + result);
    
/*
	result = Parse_IMAGE_Statement   ( mSentence ); 	
	if (result>=0)	
		return (end_of_telegram + result);
	result = Parse_GPIO_Statement   ( mSentence ); 	
	if (result>=0)	
		return (end_of_telegram + result);

*/

	// Not handled:
	nlp_reply_formulated = TRUE;
	strcpy (NLP_Response, "I don't understand. Ignoring.");		
	return end_of_telegram;
}




